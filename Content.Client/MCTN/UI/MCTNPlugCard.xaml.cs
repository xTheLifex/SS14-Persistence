using System.Numerics;
using Content.Client.MCTN.BUI;
using Content.Shared.SensorMonitoring;
using Content.Shared.MCTN.BUIStates;
using Robust.Client.AutoGenerated;
using Robust.Client.GameObjects;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Utility;

namespace Content.Client.MCTN.UI;

[GenerateTypedNameReferences]
public sealed partial class MCTNPlugCard : PanelContainer
{
    [Dependency] private readonly ILocalizationManager _loc = default!;
    [Dependency] private readonly IEntitySystemManager _entitySystem = default!;
    private readonly SpriteSystem _sprite;

    public MCTNPlugCard(MCTNBoundUserInterface bui, MCTNBasePlugState plug)
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        _sprite = _entitySystem.GetEntitySystem<SpriteSystem>();

        PlugIdentifier.Text = plug.Identifier;

        BreakerButton.Pressed = plug.Enabled;
        BreakerButton.Text = plug.Enabled ? "Enabled" : "Disabled";
        BreakerButton.Disabled = !plug.Enabled && !plug.IsNetworked;

        BreakerButton.OnPressed += (args) =>
        {
            if (bui == null) return;
            bui.SendMessage(new MCTNTogglePlugMessage(plug.Identifier));
            BreakerButton.Pressed = plug.Enabled;
        };


        if (plug.IsNetworked)
        {
            NetworkState.Text = "Online";
            NetworkState.Modulate = Color.Lime;
        }
        else
        {
            NetworkState.Text = "Offline";
            NetworkState.Modulate = Color.Red;
        }

        if (plug.IsRemoteEnabled)
        {
            RemoteAvailability.Text = "Enabled";
            RemoteAvailability.Modulate = Color.Lime;
        }
        else
        {
            RemoteAvailability.Text = "Disabled";
            RemoteAvailability.Modulate = Color.Red;
        }

        // Some better way for templating this?
        if (plug is MCTNPowerPlugState powerPlug)
        {
            PlugIdentifier.Text = plug.Identifier.Replace("power", "");
            PlugStateContainer.AddChild(new MCTNPowerStatusGrid(bui, powerPlug, this));
            PlugIcon.AddChild(new TextureRect()
            {
                Texture = _sprite.Frame0(new SpriteSpecifier.Rsi(new ResPath("Objects/Misc/books.rsi"), "icon_lightning")),
                Modulate = Color.Yellow,
                SetSize = Vector2.One * 32,
                Margin = new Thickness(0f, 0f, 5f, 0f),
            });
        }
        else if (plug is MCTNPipePlugState pipePlug)
        {
            PlugIdentifier.Text = $"L{plug.Identifier.Replace("pipe", "")}";
            PlugStateContainer.AddChild(new MCTNPipeStatusGrid(bui, pipePlug, this));
            PlugIcon.AddChild(new TextureRect()
            {
                Texture = _sprite.Frame0(new SpriteSpecifier.Rsi(new ResPath("Objects/Tools/wrench.rsi"), "icon")),
                SetSize = Vector2.One * 32,
                Margin = new Thickness(0f, 0f, 5f, 0f),
            });
        }
    }

    internal string FormatValue(SensorUnit unit, float value)
    {
        return _loc.GetString(
            "sensor-monitoring-value-display",
            ("unit", unit.ToString()),
            ("value", value));
    }
}
