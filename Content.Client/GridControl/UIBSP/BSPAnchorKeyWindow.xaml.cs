using System.Numerics;
using Content.Shared.CCVar;
using Content.Shared.GridControl.Components;
using Robust.Client.AutoGenerated;
using Robust.Client.GameObjects;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Configuration;
using Robust.Shared.Prototypes;
using Robust.Shared.Timing;
using Robust.Shared.Utility;
using static Content.Shared.GridControl.Components.BSPAnchorKeyComponent;
using static Robust.Client.UserInterface.Controls.BaseButton;

namespace Content.Client.GridControl.UIBSP;

[GenerateTypedNameReferences]
public sealed partial class BSPAnchorKeyWindow : DefaultWindow
{
    [Dependency] private readonly IGameTiming _timing = default!;
    [Dependency] private readonly IEntityManager _entMan = default!;
    private readonly SharedTransformSystem _xform = default!;


    public BSPAnchorKeyBoundUserInterface? BUI;

    private BSPAnchorKeyBoundUserInterfaceState? _lastState;

    public BSPAnchorKeyWindow()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);
        _xform = _entMan.System<TransformSystem>();

        InitiateParkBtn.OnPressed += (_) =>
        {
            BUI?.SendMessage(new BSPAnchorKeyStartPark());
        };

        CancelBtn.OnPressed += (_) =>
        {
            BUI?.SendMessage(new BSPAnchorKeyCancel());
        };

        InitiateUnparkBtn.OnPressed += (_) =>
        {
            BUI?.SendMessage(new BSPAnchorKeyStartUnpark());
        };
    }

    private Vector2 GetMyPosition()
    {
        return _xform.GetWorldPosition(BUI!.Owner);
    }

    private Vector2 GetVectorToTarget(Vector2? myPosition = null)
    {
        if (!myPosition.HasValue)
            myPosition = GetMyPosition();
        return myPosition.Value - _lastState?.ParkWorldPosition.GetValueOrDefault(myPosition.Value) ?? myPosition.Value;
    }

    private static string ToPrettyString(Vector2 vec)
    {
        var x = (int)vec.X;
        var y = (int)vec.Y;
        return $"({x}, {y})";
    }

    private static readonly TimeSpan HeavyUpdateDelay = TimeSpan.FromSeconds(1);
    private DateTime _lastHeavyUpdate = DateTime.MinValue;
    protected override void FrameUpdate(FrameEventArgs args)
    {
        base.FrameUpdate(args);
        if (_lastState == null) return;

        switch (_lastState.State)
        {
            case BSPState.Parking:
            case BSPState.Unparking:
                {
                    var delayTimeSpan = TimeSpan.FromSeconds(_lastState.State == BSPState.Parking ? _lastState.ParkDelay : _lastState.UnparkDelay);
                    var remainingTime = _lastState.RoutineStartTime.GetValueOrDefault() + delayTimeSpan - _timing.CurTime;
                    RoutineTimer.Text = $"{_lastState.State} in {Math.Max(remainingTime.TotalSeconds, 0):F0}s";
                    RoutineProgress.Value = (float)Math.Clamp((delayTimeSpan - remainingTime) / delayTimeSpan, 0, 1);
                    break;
                }
            default:
                {
                    var now = DateTime.Now;
                    if (_lastHeavyUpdate + HeavyUpdateDelay <= now)
                    {
                        _lastHeavyUpdate = now;
                        var myPosition = GetMyPosition();
                        MyCoordinates.Text = ToPrettyString(myPosition);

                        var vector = GetVectorToTarget();
                        var distance = vector.Length();
                        TargetDistance.Text = $"{distance:F0}m ";
                        if (distance <= _lastState.UnparkMaxDistance)
                        {
                            InitiateUnparkBtn.Disabled = !_lastState.CanAct;
                            TargetDistance.Modulate = Color.LimeGreen;
                        }
                        else
                        {
                            InitiateUnparkBtn.Disabled = true;
                            TargetDistance.Modulate = Color.DarkRed;
                        }
                        TargetCoordinates.Text = ToPrettyString(_lastState.ParkWorldPosition.GetValueOrDefault());
                        TargetDirection.Text = vector.GetDir().ToString();
                    }
                    break;
                }
        }

    }
    public void UpdateState(BSPAnchorKeyBoundUserInterfaceState state)
    {
        _lastState = state;

        if (!string.IsNullOrWhiteSpace(state.IdName))
        {
            PrivilegedIdButton.Text = state.IdName;
        }
        else
        {
            PrivilegedIdButton.Text = "";
        }
        GridTileCount.Text = $"{state.GridTileCount}";
        MaxPersonalClaimTileCount.Text = $"{state.MaxPersonalClaimTileCount} allowed tiles";

        var gridFound = state.GridName != null;
        if (gridFound)
        {
            GridNameLabel.Text = state.GridName;
        }
        else
        {
            GridNameLabel.Text = "*Invalid*";
        }

        if (state.ErrorMessage == null)
        {
            if (state.GridTileCount + state.GridOwnerTotalTiles > state.MaxPersonalClaimTileCount && !state.ClearOwnership)
            {
                state.ErrorMessage = "This grid will exceed the tile limit.";
            }
        }

        GridOwnerLabel.Text = state.OwnerName ?? "UNCLAIMED";

        if (!gridFound)
        {
            ErrorBox.Text = "No grid detected.";
        }
        else if (!state.IsAuth)
        {
            ErrorBox.Text = "You cannot park this grid.";
        }
        else if (state.ErrorMessage != null)
        {
            ErrorBox.Text = state.ErrorMessage;
        }
        else
        {
            ErrorBox.Text = string.Empty;
        }

        ErrorBox.Visible = !string.IsNullOrWhiteSpace(ErrorBox.Text);

        var canAct = state.CanAct;

        LiveGridDetails.Visible = state.State == BSPState.Idle || state.State == BSPState.Parking;
        IdleViewContainer.Visible = state.State == BSPState.Idle;
        ParkingViewContainer.Visible = state.State == BSPState.Parking || state.State == BSPState.Unparking;
        ParkedViewContainer.Visible = state.State == BSPState.Parked;
        ParkedViewDetails.Visible = state.State == BSPState.Parked || state.State == BSPState.Unparking;

        ToggleOwnership.Pressed = state.ClearOwnership;

        switch (state.State)
        {
            case BSPState.Idle:
                {
                    InitiateParkBtn.Disabled = !canAct;
                    break;
                }
            case BSPState.Parked:
                {
                    InitiateUnparkBtn.Disabled = true;
                    break;
                }
        }
    }

}
